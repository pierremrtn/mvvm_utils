import 'dart:async';

import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:mvvm_utils/mvvm_utils.dart';

import 'result.dart';

typedef CommandAction0<R> = FutureOr<Result<R>> Function();
typedef CommandAction1<P, R> = FutureOr<Result<R>> Function(P);
typedef CommandSuccessCallback<R> = void Function(R value);
typedef CommandFailureCallback = void Function(Object error);

enum CommandStatus {
  initial,
  running,
  success,
  failure,
}

abstract class CommandRestrictionController extends Listenable {
  const CommandRestrictionController();
  bool get enabled;
}

class DependsOnCommands
    with ChangeNotifier
    implements CommandRestrictionController {
  DependsOnCommands(List<Command> commands)
      : _commands = commands,
        _allCommands = Listenable.merge(commands) {
    _allCommands.addListener(notifyListeners);
  }

  final Listenable _allCommands;
  final List<Command> _commands;

  @override
  bool get enabled => _commands.none((c) => c.succeeded == false);
}

class CommandRestrictionSelector<T extends Listenable>
    implements CommandRestrictionController {
  CommandRestrictionSelector(this.listenable, this.selector);

  final T listenable;
  final bool Function(T) selector;

  @override
  bool get enabled => selector(listenable);

  @override
  void addListener(VoidCallback listener) => listenable.addListener(listener);

  @override
  void removeListener(VoidCallback listener) =>
      listenable.removeListener(listener);
}

class Command<R> with ChangeNotifier {
  Command({
    CommandRestrictionController? restrictionController,
    this.onFailure,
    this.onSuccess,
  }) : _restrictionController = restrictionController {
    _restrictionController?.addListener(notifyListeners);
  }

  final CommandSuccessCallback<R>? onSuccess;
  final CommandFailureCallback? onFailure;
  final CommandRestrictionController? _restrictionController;

  Result<R>? _result;
  CommandStatus _status = CommandStatus.initial;

  /// Returns the status of the command
  /// Command are in status [initial] until execute has been called
  /// at least once
  CommandStatus get status => _status;

  bool get enabled => _restrictionController?.enabled ?? true;
  bool get disabled => !enabled;
  bool get initial => status == CommandStatus.initial;
  bool get running => status == CommandStatus.running;
  bool get failed => status == CommandStatus.failure;
  bool get succeeded => status == CommandStatus.success;
  bool get completed => failed || succeeded;

  Object? get error => switch (result) {
        Failure(:final error) => error,
        _ => null,
      };
  R? get value => switch (result) {
        Success(:final value) => value,
        _ => null,
      };

  /// Return the result of the last execute call
  /// Calling execute **does not** reset result value while the command is running
  /// This allows to keep displaying previous result (such as error message) until
  /// a new result is available.
  ///
  /// If you need the status of the currently running action, uses [status] instead
  Result<R>? get result => _result;

  FutureOr<Result<R>?> _execute(FutureOr<Result<R>> Function() action) async {
    if (running || _restrictionController?.enabled == false) return null;

    _status = CommandStatus.running;
    _result = null;
    notifyListeners();

    try {
      _result = await action();
      _status = switch (_result as Result<R>) {
        Success() => CommandStatus.success,
        Failure() => CommandStatus.failure,
      };
    } catch (e) {
      _status = CommandStatus.failure;
      _result = Failure(e);
    } finally {
      switch (_result) {
        case Success(:final value):
          onSuccess?.call(value);
        case Failure(:final error):
          onFailure?.call(error);
        default:
      }
      notifyListeners();
    }
    return _result;
  }

  @override
  void dispose() {
    _restrictionController?.removeListener(notifyListeners);
    super.dispose();
  }
}

/// A [Command] that accepts no arguments.
class Command0<T> extends Command<T> {
  /// Creates a [Command0] with the provided [CommandAction0].
  Command0(
    this._action, {
    super.restrictionController,
    super.onFailure,
    super.onSuccess,
  });

  final CommandAction0<T> _action;

  FutureOr<Result<T>?> Function()? toNullableCallbackWithOptions({
    required bool nullWhenDisabled,
    required bool nullWhenRunning,
  }) =>
      (nullWhenDisabled && disabled) || (nullWhenRunning && running)
          ? null
          : this.execute;

  FutureOr<Result<T>?> Function()? get toNullableCallback =>
      toNullableCallbackWithOptions(
        nullWhenDisabled: true,
        nullWhenRunning: true,
      );

  /// Executes the command's action.
  /// Returns the result generated by this action execution.
  /// If the command is already running, returns null.
  FutureOr<Result<T>?> execute() async {
    return await _execute(() => _action());
  }
}

class Command1<P, R> extends Command<R> {
  Command1(
    this._action, {
    super.restrictionController,
    super.onFailure,
    super.onSuccess,
  });

  final CommandAction1<P, R> _action;

  /// Executes the command's action.
  /// Returns the result generated by this action execution.
  /// If the command is already running, returns null.
  FutureOr<Result<R>?> execute(P param) async {
    return await _execute(() => _action(param));
  }
}
